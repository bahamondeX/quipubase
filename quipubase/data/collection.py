"""Data Modelation module"""

import json
import os
from pathlib import Path
from typing import Any, Iterator, Optional, Type, TypeVar
from uuid import uuid4

import orjson
from pydantic import BaseModel, Field  # pylint: disable=W0611
from rocksdict import Options  # pylint: disable=E0611
from rocksdict import PlainTableFactoryOptions  # pylint: disable=E0611
from rocksdict import Rdict, SliceTransform

from ..models.typedefs import JsonSchemaModel
from ..models.utils import encrypt, get_logger

T = TypeVar("T", bound="Collection")

logger = get_logger("[Collections]")


class Collection(BaseModel):
    """
    Collection

    A base model class for managing a RocksDB-backed collection of records. This class provides methods for creating, retrieving, updating, deleting, and querying records, as well as managing the underlying database schema and configuration.

    Attributes:
        id (Optional[UUID]): The unique identifier for the record, autogenerated by default.

    Methods:
        col() -> Rdict:
            Get or create a RocksDB instance for this collection.

        col_path() -> str:
            Get the absolute path to the collection directory.

        col_json_schema() -> JsonSchemaModel:
            Create and persist a JSON schema for this collection.

        cpu_count() -> int:
            Get the number of CPU cores available.

        tool_definition() -> dict[str, Any]:
            Generate tool parameters for `OpenAI` function calling.

        tool_param() -> dict:
            Generate tool parameters for `Anthropic` function calling.

        options() -> Options:
            Configure RocksDB options for optimal performance.

        retrieve(cls, *, id: UUID) -> Optional[T]:
            Retrieve a single record by its ID.

        create(self) -> None:
            Save or update the current record in the database.

        delete(cls, *, id: UUID) -> bool:
            Delete a record by its ID.

        find(cls, *, limit: int = 100, offset: int = 0, **kwargs: Any) -> Iterator[T]:

        update(cls, *, id: UUID, **kwargs: Any) -> Optional[T]:
            Update specific fields of a record by its ID.

        destroy(cls) -> int:
            Delete the entire collection and its data.

        init(cls) -> None:
            Initialize the collection by creating necessary directories and files.
    """

    id: Optional[str] = Field(default_factory=lambda: str(uuid4()))

   
    def __init__(self, **kwargs: Any):
        super().__init__(**kwargs)
        if self.id is None:
            self.id = str(uuid4())

    def __repr__(self):
        return self.model_dump_json(indent=4)

    def __str__(self):
        return self.__repr__()

    @classmethod
    def col(cls) -> Rdict:
        """Get or create a RocksDB instance for this collection."""
        return Rdict(cls.col_path(), cls.options())

    @classmethod
    def col_path(cls):
        """The absolute path to the collection directory."""
        home_dir = Path.home().as_posix()
        return os.path.join(home_dir, ".data", cls.col_id())

    @classmethod
    def col_id(cls):
        return encrypt(json.dumps(cls.model_json_schema(), sort_keys=True))

    @classmethod
    def col_json_schema(cls) -> JsonSchemaModel:
        """Create a schema for this collection"""
        data = cls.model_json_schema()
        path = Path(os.path.join(cls.col_path(), "schema.json"))
        if not path.exists():
            os.makedirs(os.path.dirname(path), exist_ok=True)
            path.write_text(json.dumps(data, sort_keys=True))
        return JsonSchemaModel(**data)

    @classmethod
    def cpu_count(cls):
        """Get the number of CPU cores available."""
        return os.cpu_count() or 1

    @classmethod
    def tool_openai(cls) -> dict[str, Any]:
        """Generate tool parameters for `OpenAI` function calling."""
        return {
            "type": "function",
            "function": {
                "name": cls.__name__,
                "description": cls.__doc__ or "",
                "parameters": cls.model_json_schema().get("properties", {}),
            },
        }

    @classmethod
    def tool_anthropic(cls) -> dict[str, Any]:
        """Generate tool parameters for `Anthropic` function calling."""
        return {
            "input_schema": cls.model_json_schema(),
            "name": cls.__name__,
            "description": cls.__doc__ or "",
            "cache_control": {"type": "ephemeral"},
        }

    @classmethod
    def options(cls) -> Options:
        """Configure RocksDB options for optimal performance."""
        opt = Options()
        opt.create_if_missing(True)
        opt.set_max_background_jobs(cls.cpu_count())
        opt.set_write_buffer_size(0x10000000)
        opt.set_level_zero_file_num_compaction_trigger(4)
        opt.set_max_bytes_for_level_base(0x40000000)
        opt.set_target_file_size_base(0x10000000)
        opt.set_max_bytes_for_level_multiplier(4.0)
        opt.set_prefix_extractor(SliceTransform.create_max_len_prefix(8))
        opt.set_plain_table_factory(PlainTableFactoryOptions())
        return opt

    @classmethod
    def retrieve(cls: Type[T], *, id: str) -> Optional[T]:  # pylint: disable=W0622
        """Retrieve a single record by ID."""
        raw_data = cls.col().get(id)
        if raw_data is None:
            return None
        json_data = orjson.loads(raw_data)  # pylint: disable=E1101
        return cls.model_validate(json_data)

    def create(self) -> None:
        """Save/update the record in the database."""
        if self.id is None:
            self.id = str(uuid4())
        data = self.model_dump_json(exclude_none=True).encode("utf-8")
        self.col().put(self.id, data)  # pylint: disable=E1101
        assert (
            self.col().get(self.id) == data  # pylint: disable=E1101
        ), f"Failed to persist record {self.id}"

    @classmethod
    def delete(cls, *, id: str) -> bool:  # pylint: disable=W0622
        """Delete a record by ID."""
        try:
            cls.col().delete(id)
            return True
        except KeyError:
            return False

    @classmethod
    def find(
        cls: Type[T], *, limit: int = 100, offset: int = 0, **kwargs: Any
    ) -> Iterator[T]:
        """
        Find records matching the given criteria.

        Args:
            limit: Max records to return
            offset: Records to skip
            **kwargs: Field filters

        Yields:
            Matching model instances
        """
        db = cls.col()
        riter = db.iter()
        riter.seek_to_first()

        # Saltar offset inicial
        while riter.valid() and offset > 0:
            riter.next()
            offset -= 1

        # Iterar hasta cumplir el lÃ­mite
        while riter.valid() and limit > 0:
            try:
                data = orjson.loads(riter.value())  # pylint: disable=E1101
                if all(data.get(k) == v for k, v in kwargs.items() if k != "id"):
                    yield cls.model_validate(data)
                    limit -= 1
            except Exception as e:  # pylint: disable=W0718
                logger.error("Error parsing record: %s", e)
            riter.next()

    @classmethod
    def update(
        cls: Type[T], *, id: str, **kwargs: Any
    ) -> Optional[T]:  # pylint: disable=W0622
        """Update specific fields of a record by ID."""
        # Get the current record
        record = cls.retrieve(id=id)
        if record is None:
            return None

        # Update the fields
        record_dict = record.model_dump()
        for field_name, new_value in kwargs.items():
            if field_name in record_dict and field_name != "id":
                record_dict[field_name] = new_value

        # Create updated instance
        updated_record = cls.model_validate(record_dict)
        updated_record.create()

        return updated_record

    @classmethod
    def init(cls):
        """Initialize the collection."""
        if not os.path.exists(cls.col_path()):
            os.makedirs(cls.col_path())
            path = Path(cls.col_path()) / "README.md"
            path.write_text(cls.__doc__ or "")


Collection.model_rebuild()

<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Quipubase | Modern Database for Frontend Developers</title>
	<script src="https://cdn.tailwindcss.com"></script>
	<script>
		tailwind.config = {
			theme: {
				extend: {
					colors: {
						'stone-warm': '#d4c4a7',
						'copper': '#b87333',
						'teal-deep': '#2d5a5a',
						'sage': '#7a8471'
					}
				}
			}
		}
	</script>
	<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
	<style>
		body {
			font-family: 'Inter', sans-serif;
		}

		.gradient-bg {
			background: linear-gradient(135deg, #2d5a5a 0%, #4a6741 100%);
		}

		.code-block {
			background: #1e1e1e;
			border-radius: 8px;
			border: 1px solid #333;
			position: relative;
			overflow: hidden;
		}

		.tab-button {
			transition: all 0.2s ease;
		}

		.tab-button.active {
			background: #2d5a5a;
			color: white;
		}

		.copy-btn {
			position: absolute;
			top: 8px;
			right: 8px;
			background: #b87333;
			color: white;
			border: none;
			padding: 4px 8px;
			border-radius: 4px;
			font-size: 12px;
			cursor: pointer;
			opacity: 0;
			transition: opacity 0.2s;
		}

		.code-block:hover .copy-btn {
			opacity: 1;
		}

		.section {
			display: none;
		}

		.section.active {
			display: block;
		}

		.nav-item {
			transition: all 0.2s ease;
			border-left: 3px solid transparent;
		}

		.nav-item:hover {
			background: rgba(45, 90, 90, 0.1);
			border-left-color: #b87333;
		}

		.nav-item.active {
			background: rgba(45, 90, 90, 0.15);
			border-left-color: #2d5a5a;
			font-weight: 500;
		}

		.feature-card {
			background: white;
			border: 1px solid #e5e7eb;
			border-radius: 12px;
			padding: 24px;
			transition: all 0.3s ease;
			box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
		}

		.feature-card:hover {
			transform: translateY(-2px);
			box-shadow: 0 8px 25px rgba(45, 90, 90, 0.15);
		}

		.logo-container {
			width: 48px;
			height: 48px;
			background: url('data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDgiIGhlaWdodD0iNDgiIHZpZXdCb3g9IjAgMCA0OCA0OCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMjQiIGN5PSIyNCIgcj0iMjMiIGZpbGw9IiMyZDVhNWEiIHN0cm9rZT0iI2I4NzMzMyIgc3Ryb2tlLXdpZHRoPSIyIi8+CjxwYXRoIGQ9Ik0xNiAxNkgzMlYzMkgxNlYxNloiIGZpbGw9IiNiODczMzMiLz4KPHBhdGggZD0iTTIwIDIwSDI4VjI4SDIwVjIwWiIgZmlsbD0iIjdBODQ3MSIvPgo8L3N2Zz4K') center/contain no-repeat;
		}

		/* Styles for Todo List example */
		.todo-list {
			background-color: #ffffff;
			padding: 24px;
			border-radius: 12px;
			box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
			max-width: 600px;
			margin: 0 auto;
		}

		.todo-list h2 {
			font-size: 1.75rem;
			font-weight: 600;
			margin-bottom: 20px;
			color: #2d5a5a;
		}

		.todo-list form {
			display: flex;
			gap: 10px;
			margin-bottom: 20px;
		}

		.todo-list input[type="text"] {
			flex-grow: 1;
			padding: 10px 15px;
			border: 1px solid #e5e7eb;
			border-radius: 8px;
			font-size: 1rem;
			outline: none;
			transition: border-color 0.2s;
		}

		.todo-list input[type="text"]:focus {
			border-color: #b87333;
		}

		.todo-list button {
			background-color: #b87333;
			color: white;
			padding: 10px 20px;
			border: none;
			border-radius: 8px;
			cursor: pointer;
			font-size: 1rem;
			transition: background-color 0.2s;
		}

		.todo-list button:hover {
			background-color: #a0662d;
		}

		.todo-list ul {
			list-style: none;
			padding: 0;
		}

		.todo-item {
			display: flex;
			align-items: center;
			gap: 12px;
			padding: 12px 0;
			border-bottom: 1px solid #f3f4f6;
		}

		.todo-item:last-child {
			border-bottom: none;
		}

		.todo-item input[type="checkbox"] {
			width: 20px;
			height: 20px;
			accent-color: #2d5a5a;
			cursor: pointer;
		}

		.todo-item span {
			flex-grow: 1;
			font-size: 1rem;
			color: #374151;
		}

		.todo-item span.completed {
			text-decoration: line-through;
			opacity: 0.6;
			color: #6b7280;
		}

		.todo-item button {
			background-color: #dc2626;
			padding: 6px 12px;
			font-size: 0.875rem;
			border-radius: 6px;
		}

		.todo-item button:hover {
			background-color: #b91c1c;
		}

		.todo-list .loading,
		.todo-list .error {
			text-align: center;
			padding: 20px;
			color: #6b7280;
			font-style: italic;
		}
	</style>
</head>

<body class="bg-gray-50">
	<header class="gradient-bg text-white shadow-lg">
		<div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-6">
			<div class="flex items-center justify-between">
				<div class="flex items-center space-x-4">
					<div class="logo-container"></div>
					<div>
						<h1 class="text-2xl font-bold">Quipubase</h1>
						<p class="text-teal-100 text-sm">Real-time Database for Modern Frontend</p>
					</div>
				</div>
				<div class="hidden md:flex items-center space-x-6">
					<a href="https://github.com/bahamondeX/quipubase-client-typescript"
						class="text-teal-100 hover:text-white flex items-center space-x-2" target="_blank">
						<svg class="w-6 h-6" fill="currentColor" viewBox="0 0 24 24" aria-hidden="true">
							<path fill-rule="evenodd"
								d="M12 2C6.477 2 2 6.484 2 12.017c0 4.425 2.865 8.18 6.839 9.504.499.09.679-.217.679-.481 0-.237-.008-.865-.013-1.703-2.782.602-3.369-1.34-3.369-1.34-.454-1.156-1.11-1.46-1.11-1.46-.908-.618.069-.606.069-.606 1.003.07 1.531 1.032 1.531 1.032.892 1.529 2.341 1.089 2.91.833.091-.647.351-1.088.636-1.338-2.22-.253-4.555-1.113-4.555-4.931 0-1.091.39-1.988 1.029-2.688-.103-.253-.446-1.272.098-2.65 0 0 .84-.27 2.75 1.026A9.564 9.564 0 0112 6.844c.85.004 1.701.114 2.503.344 1.909-1.296 2.747-1.027 2.747-1.027.546 1.379.202 2.398.099 2.65.64.7 1.028 1.597 1.028 2.688 0 3.839-2.339 4.675-4.562 4.922.357.307.676.917.676 1.854 0 1.338-.012 2.419-.012 2.747 0 .268.18.577.685.479C21.133 20.283 24 16.529 24 12.017 24 6.484 19.522 2 14 2h-2z" />
						</svg>
						<span>GitHub</span>
					</a>
					<a href="/docs" class="bg-copper px-4 py-2 rounded-lg hover:bg-opacity-90 transition">Get
						Started</a>
				</div>
			</div>
		</div>
	</header>
	<div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
		<div class="grid grid-cols-1 lg:grid-cols-4 gap-8">
			<aside class="lg:col-span-1">
				<nav class="sticky top-8 space-y-1">
					<div class="text-xs font-semibold text-gray-500 uppercase tracking-wider px-3 py-2">Getting Started
					</div>
					<a href="#overview" class="nav-item block px-3 py-2 text-sm text-gray-700 rounded-md active"
						data-section="overview">Overview</a>
					<a href="#installation" class="nav-item block px-3 py-2 text-sm text-gray-700 rounded-md"
						data-section="installation">Installation</a>
					<a href="#quickstart" class="nav-item block px-3 py-2 text-sm text-gray-700 rounded-md"
						data-section="quickstart">Quick Start</a>

					<div class="text-xs font-semibold text-gray-500 uppercase tracking-wider px-3 py-2 mt-6">Vue.js
						Integration</div>
					<a href="#vue-setup" class="nav-item block px-3 py-2 text-sm text-gray-700 rounded-md" data-section="vue-setup">Vue
						Setup</a>
					<a href="#vue-examples" class="nav-item block px-3 py-2 text-sm text-gray-700 rounded-md"
						data-section="vue-examples">Vue Examples</a>
					
					<div class="text-xs font-semibold text-gray-500 uppercase tracking-wider px-3 py-2 mt-6">React
						Integration</div>
					<a href="#react-setup" class="nav-item block px-3 py-2 text-sm text-gray-700 rounded-md"
						data-section="react-setup">React Setup</a>
					<a href="#react-examples" class="nav-item block px-3 py-2 text-sm text-gray-700 rounded-md"
						data-section="react-examples">React Examples</a>
					
					<div class="text-xs font-semibold text-gray-500 uppercase tracking-wider px-3 py-2 mt-6">Features &
						Concepts</div>
					<a href="#realtime" class="nav-item block px-3 py-2 text-sm text-gray-700 rounded-md" data-section="realtime">Real-time
						Updates</a>
					<a href="#schema-validation" class="nav-item block px-3 py-2 text-sm text-gray-700 rounded-md"
						data-section="schema-validation">JSON Schema & Validation</a>
					<a href="#vectors" class="nav-item block px-3 py-2 text-sm text-gray-700 rounded-md" data-section="vectors">AI & Vector
						Search</a>
					<a href="#document-processing" class="nav-item block px-3 py-2 text-sm text-gray-700 rounded-md"
						data-section="document-processing">Document Processing</a>
					<a href="#file-chunking" class="nav-item block px-3 py-2 text-sm text-gray-700 rounded-md"
						data-section="file-chunking">File Chunking</a>
					</nav>
					</aside>
			<main class="lg:col-span-3">
				<section id="overview" class="section active">
					<div class="mb-8">
						<h2 class="text-3xl font-bold text-gray-900 mb-4">Welcome to Quipubase: Your Frontend's New Best
							Friend!</h2>
						<p class="text-lg text-gray-600 mb-6">
							Quipubase is a modern, real-time document collection database crafted specifically for
							frontend developers.
							Say goodbye to backend complexities and hello to building reactive, data-driven applications
							with Vue.js, React, and beyond, effortlessly.
							It's a database that speaks your language: JavaScript, JSON, and real-time magic!
						</p>
						<p class="text-lg text-gray-600 mb-6">
							At its core, Quipubase is powered by **JSON Schema**, ensuring your data is always
							structured, validated, and ready for prime time.
							With built-in **AI capabilities** and **vector embeddings for similarity search**, your
							applications can understand and retrieve data in ways never before possible.
							Plus, it's designed to make **document processing** a breeze, letting you focus on the user
							experience.
						</p>
					</div>
					<div class="grid grid-cols-1 md:grid-cols-2 gap-6">
						<div class="feature-card">
							<div class="w-12 h-12 bg-teal-deep rounded-lg flex items-center justify-center mb-4">
								<svg class="w-6 h-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
									<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
										d="M13 10V3L4 14h7v7l9-11h-7z"></path>
								</svg>
							</div>
							<h3 class="text-lg font-semibold text-gray-900 mb-2">Blazing Fast Real-time Updates</h3>
							<p class="text-gray-600">Experience instant data synchronization across all connected
								clients with our robust WebSocket-based pub/sub system. Your UI updates before you can
								even blink!</p>
							</div>
							<div class="feature-card">
								<div class="w-12 h-12 bg-copper rounded-lg flex items-center justify-center mb-4">
									<svg class="w-6 h-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
										<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
											d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z">
										</path>
									</svg>
								</div>
								<h3 class="text-lg font-semibold text-gray-900 mb-2">Rock-Solid JSON Schema Validation</h3>
								<p class="text-gray-600">Leverage built-in Zod integration for type-safe data models and
									automatic validation. Keep your data clean and consistent without breaking a sweat.</p>
							</div>
							<div class="feature-card">
								<div class="w-12 h-12 bg-sage rounded-lg flex items-center justify-center mb-4">
									<svg class="w-6 h-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
										<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
											d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path>
									</svg>
								</div>
								<h3 class="text-lg font-semibold text-gray-900 mb-2">AI-Powered Vector Search</h3>
								<p class="text-gray-600">Unlock intelligent data retrieval with AI-powered semantic search
									and built-in embedding models. Find what you mean, not just what you type!</p>
							</div>
							<div class="feature-card">
								<div class="w-12 h-12 bg-stone-warm rounded-lg flex items-center justify-center mb-4">
									<svg class="w-6 h-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
										<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
											d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z">
										</path>
										<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z">
										</path>
									</svg>
								</div>
								<h3 class="text-lg font-semibold text-gray-900 mb-2">Framework Agnostic & Developer Friendly
								</h3>
								<p class="text-gray-600">Works seamlessly with Vue.js, React, and any modern JavaScript
									framework. Designed for developers, by developers, with a focus on delightful DX.</p>
							</div>
							<div class="feature-card">
								<div class="w-12 h-12 bg-teal-deep rounded-lg flex items-center justify-center mb-4">
									<svg class="w-6 h-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
										<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
											d="M9 13h6m-3-3v6m5 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z">
										</path>
									</svg>
								</div>
								<h3 class="text-lg font-semibold text-gray-900 mb-2">Effortless Document Processing</h3>
								<p class="text-gray-600">Store, manage, and query diverse document types with ease.
									Quipubase is your go-to for building content management systems, knowledge bases, and
									more!</p>
							</div>
							<div class="feature-card">
								<div class="w-12 h-12 bg-sage rounded-lg flex items-center justify-center mb-4">
									<svg class="w-6 h-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
										<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
											d="M8 14v3m4-3v3m4-3v3M3 21h18M3 10h18M3 7l9-4 9 4M4 10h16v11H4V10z"></path>
									</svg>
								</div>
								<h3 class="text-lg font-semibold text-gray-900 mb-2">Collections, Not Tables</h3>
								<p class="text-gray-600">Organize your data into flexible document collections, designed for
									the dynamic needs of modern applications. No rigid tables, just pure data freedom.</p>
							</div>
							</div>
							</section>
							<section id="installation" class="section">
								<h2 class="text-3xl font-bold text-gray-900 mb-6">Installation</h2>
								<p class="text-lg text-gray-600 mb-6">Getting Quipubase up and running is as easy as pie. Choose
									your preferred method below!</p>

					<div class="mb-6">
						<h3 class="text-xl font-semibold text-gray-800 mb-3">Package Manager</h3>
						<div class="code-block">
							<button class="copy-btn">Copy</button>
							<pre class="p-4 text-sm text-gray-300 overflow-x-auto"><code># npm
																									npm install quipubase

# yarn
yarn add quipubase

# pnpm
pnpm add quipubase</code></pre>
</div>
</div>
<div class="mb-6">
	<h3 class="text-xl font-semibold text-gray-800 mb-3">CDN (Browser)</h3>
	<p class="text-gray-600 mb-3">For quick prototyping or simple projects, you can include
		Quipubase directly in your HTML:</p>
	<div class="code-block">
		<button class="copy-btn">Copy</button>
		<pre
			class="p-4 text-sm text-gray-300 overflow-x-auto"><code>&lt;script src="https://cdn.jsdelivr.net/npm/quipubase@latest/dist/index.umd.js"&gt;&lt;/script&gt;</code></pre>
	</div>
</div>
</section>
				<section id="quickstart" class="section">
					<h2 class="text-3xl font-bold text-gray-900 mb-6">Quick Start: Your First Quipubase App!</h2>
					<p class="text-lg text-gray-600 mb-6">
						Let's get your hands dirty and build a simple application with Quipubase.
						We'll define a data model, initialize the client, and create your first collection.
					</p>

					<div class="mb-6">
						<h3 class="text-xl font-semibold text-gray-800 mb-3">1. Define Your Model (with Zod!)</h3>
						<p class="text-gray-600 mb-3">
							Quipubase loves structured data! Define your data models using Zod schemas for robust
							validation and type safety.
							It's like giving your data a superpower!
						</p>
						<div class="code-block">
							<button class="copy-btn">Copy</button>
							<pre class="p-4 text-sm text-gray-300 overflow-x-auto"><code>import { z } from 'zod';
																																			import { BaseModel } from 'quipubase'; // Updated import

class Todo extends BaseModel {
    title!: string;
	completed!: boolean;
	createdAt!: Date;

    static schema() {
        return z.object({
			id: z.string().optional(),
			title: z.string().min(1, 'Title is required'),
			completed: z.boolean().default(false),
			createdAt: z.date().default(() => new Date())
        });
    }
}</code></pre>
						</div>
					</div>
					<div class="mb-6">
						<h3 class="text-xl font-semibold text-gray-800 mb-3">2. Initialize Your Quipubase Client</h3>
						<p class="text-gray-600 mb-3">
							Connect to your Quipubase server. Think of this as opening the door to your real-time data
							kingdom!
						</p>
						<div class="code-block">
							<button class="copy-btn">Copy</button>
							<pre class="p-4 text-sm text-gray-300 overflow-x-auto"><code>import { QuipuBase } from 'quipubase'; // Updated import

// Replace 'http://localhost:5454' with your Quipubase server URL
const client = new QuipuBase&lt;Todo&gt;('http://localhost:5454');</code></pre>
</div>
					</div>
					<div class="mb-6">
						<h3 class="text-xl font-semibold text-gray-800 mb-3">3. Create a Collection & Add Data</h3>
						<p class="text-gray-600 mb-3">
							Collections are where your documents live. Let's create one and add some initial data.
							The `publishEvent` method makes your data available in real-time to all subscribers!
						</p>
						<div class="code-block">
							<button class="copy-btn">Copy</button>
							<pre class="p-4 text-sm text-gray-300 overflow-x-auto"><code>// Create a new collection for your Todos. Uses modelJsonSchema() for schema definition.
																														const collection = await client.createCollection(Todo);
																														
																														// Add some data to your new collection. Use .modelDump() to get plain object.
																														await client.publishEvent(collection.id, {
																														    event: 'create', // 'create', 'update', or 'delete'
																														    data: new Todo({
																														        title: 'Learn Quipubase like a boss!',
																														        completed: false
																														    }).modelDump() // Updated: Use .modelDump()
																														});
																														
																														console.log('First todo added to Quipubase!');</code></pre>
						</div>
						</div>
				</section>
				<section id="vue-setup" class="section">
					<h2 class="text-3xl font-bold text-gray-900 mb-6">Vue.js Setup: Reactive Data, Vue-Style!</h2>
					<p class="text-lg text-gray-600 mb-6">
						Integrating Quipubase into your Vue.js application is seamless.
						We recommend using a plugin for global access and a composable for reactive data fetching.
					</p>

					<div class="mb-6">
						<h3 class="text-xl font-semibold text-gray-800 mb-3">Plugin Installation (<code>main.js</code>)
						</h3>
						<p class="text-gray-600 mb-3">
							Make your Quipubase client globally available across your Vue app.
						</p>
						<div class="code-block">
							<button class="copy-btn">Copy</button>
							<pre class="p-4 text-sm text-gray-300 overflow-x-auto"><code>// plugins/quipubase.js
																														import { QuipuBase } from 'quipubase'; // Updated import

export default {
install(app, options) {
const client = new QuipuBase(options.baseUrl);
app.config.globalProperties.$quipu = client; // For Options API
app.provide('quipu', client); // For Composition API
}
};

// main.js
import { createApp } from 'vue';
import App from './App.vue';
import QuipubasePlugin from './plugins/quipubase';

const app = createApp(App);
app.use(QuipubasePlugin, { baseUrl: 'http://localhost:5454' }); // Your Quipubase server URL
app.mount('#app');</code></pre>
</div>
</div>
<div class="mb-6">
	<h3 class="text-xl font-semibold text-gray-800 mb-3">Composable (Recommended for Vue 3)</h3>
	<p class="text-gray-600 mb-3">
		A custom composable simplifies subscribing to real-time data and publishing events within
		your components.
		It's reactive, clean, and keeps your components focused on presentation!
	</p>
	<div class="code-block">
							<button class="copy-btn">Copy</button>
							<pre class="p-4 text-sm text-gray-300 overflow-x-auto"><code>// composables/useQuipubase.js
																																			import { ref, onMounted, onUnmounted, inject } from 'vue';
																																			import { BaseModel } from 'quipubase'; // Ensure BaseModel is imported if used in types
																																			
																																			export function useQuipubase(collectionId) {
																																			    const client = inject('quipu'); // Get the Quipubase client from provide/inject
																																			    const data = ref([]);
																																			    const loading = ref(false);
																																			    const error = ref(null);
																																			
																																			    let unsubscribe = null;
																																			
																																			    const subscribe = async () => {
																																			        if (!client) {
																																			            error.value = new Error('Quipubase client not injected. Ensure QuipubaseProvider is used.');
																																			            return;
																																			        }
																																			        try {
			loading.value = true;
			// The callback now receives SSEEvent<T>
				unsubscribe = await client.subscribeToEvents(collectionId, (sseEvent) => {
				const { event, data: eventData } = sseEvent; // Destructure SSEEvent
			
				// Handle different event types to update reactive data
				if (event === 'create') {
				data.value.push(eventData);
				} else if (event === 'update') {
				const index = data.value.findIndex(item => item.id === eventData.id);
				if (index !== -1) data.value[index] = eventData;
				} else if (event === 'delete') {
				data.value = data.value.filter(item => item.id !== eventData.id);
				}
			});
			} catch (err) {
			error.value = err;
			console.error("Failed to subscribe to Quipubase events:", err);
			} finally {
			loading.value = false;
		}
	};

	const publish = async (event, eventData) => {
	if (!client) {
	error.value = new Error('Quipubase client not injected.');
	return;
	}
	try {
			await client.publishEvent(collectionId, { event, data: eventData });
			} catch (err) {
			error.value = err;
			console.error("Failed to publish event to Quipubase:", err);
			}
	};
	
	onMounted(subscribe); // Start subscription when component mounts
	onUnmounted(() => unsubscribe?.()); // Clean up subscription when component unmounts
	
	return { data, loading, error, publish };
	}</code></pre>
	</div>
	</div>
	</section>
	<section id="vue-examples" class="section">
		<h2 class="text-3xl font-bold text-gray-900 mb-6">Vue.js Examples: Bringing Data to Life!</h2>
		<p class="text-lg text-gray-600 mb-6">
			See Quipubase in action with a classic Todo List component, demonstrating real-time updates and
			data manipulation.
		</p>
		<div class="mb-6">
			<h3 class="text-xl font-semibold text-gray-800 mb-3">Todo List Component
				(<code>TodoList.vue</code>)</h3>
			<div class="code-block">
				<button class="copy-btn">Copy</button>
				<pre class="p-4 text-sm text-gray-300 overflow-x-auto"><code>&lt;template&gt;
					  &lt;div class="todo-list"&gt;
					    &lt;h2&gt;My Awesome Todos&lt;/h2&gt;
					
					    &lt;form @submit.prevent="addTodo"&gt;
					      &lt;input
					        v-model="newTodo"
					        placeholder="Add a new Quipubase-powered todo..."
					        required
					        type="text"
					      &gt;
					      &lt;button type="submit"&gt;Add Todo&lt;/button&gt;
					    &lt;/form&gt;
					
					    &lt;div v-if="loading" class="loading"&gt;Loading your real-time todos...&lt;/div&gt;
					    &lt;div v-else-if="error" class="error"&gt;Error: {{ error.message }}&lt;/div&gt;
					    &lt;div v-else-if="data.length === 0" class="loading"&gt;No todos yet! Add one above.&lt;/div&gt;
					
					    &lt;ul v-else&gt;
					      &lt;li v-for="todo in data" :key="todo.id" class="todo-item"&gt;
					        &lt;input
					          type="checkbox"
					          :checked="todo.completed"
					          @change="toggleTodo(todo)"
					        &gt;
					        &lt;span :class="{ completed: todo.completed }"&gt;{{ todo.title }}&lt;/span&gt;
					        &lt;button @click="deleteTodo(todo)"&gt;Delete&lt;/button&gt;
					      &lt;/li&gt;
					    &lt;/ul&gt;
					  &lt;/div&gt;
					&lt;/template&gt;
					
					&lt;script setup&gt;
					import { ref } from 'vue';
					import { useQuipubase } from '@/composables/useQuipubase'; // Adjust path as needed
					import { BaseModel } from 'quipubase'; // Import BaseModel to define Todo
					import { z } from 'zod'; // Import z for schema definition
					
					// Define the Todo model here or import it from a shared file
					class Todo extends BaseModel {
					    title;
					    completed;
					    createdAt;
					
					    static schema() {
					        return z.object({
					            id: z.string().optional(),
					            title: z.string().min(1, 'Title is required'),
					            completed: z.boolean().default(false),
					            createdAt: z.string().transform((str) => new Date(str)).default(() => new Date().toISOString()) // Store as ISO string
					        });
	}
}

const props = defineProps(['collectionId']);

// Use the composable to get reactive data and publish function
const { data, loading, error, publish } = useQuipubase(props.collectionId);

const newTodo = ref('');

const addTodo = async () => {
if (!newTodo.value.trim()) return;

// Create a new Todo instance and use .modelDump()
const todoInstance = new Todo({
title: newTodo.value,
completed: false,
createdAt: new Date().toISOString()
});

await publish('create', todoInstance.modelDump()); // Use .modelDump()

newTodo.value = ''; // Clear input after adding
};

const toggleTodo = async (todo) => {
// Create a new Todo instance from existing data and update it
const updatedTodoInstance = new Todo({
...todo,
completed: !todo.completed
});
await publish('update', updatedTodoInstance.modelDump()); // Use .modelDump()
};

const deleteTodo = async (todo) => {
await publish('delete', { id: todo.id }); // Only need the ID for delete
};
&lt;/script&gt;

&lt;style scoped&gt;
/* Styles are already defined in the main HTML for .todo-list, .todo-item, etc. */
/* Add any component-specific overrides here if necessary */
&lt;/style&gt;</code></pre>
</div>
					</div>
					</section>
					<section id="react-setup" class="section">
						<h2 class="text-3xl font-bold text-gray-900 mb-6">React Setup: Hooks, Context, and Real-time Bliss!
						</h2>
						<p class="text-lg text-gray-600 mb-6">
							For React applications, we leverage Context for client provision and custom hooks for managing
							real-time data subscriptions.
							It's the React way to keep things tidy and reactive!
						</p>

					<div class="mb-6">
						<h3 class="text-xl font-semibold text-gray-800 mb-3">Context Provider
							(<code>contexts/QuipubaseContext.jsx</code>)</h3>
						<p class="text-gray-600 mb-3">
							Wrap your application with the `QuipubaseProvider` to make the client instance available to
							any nested component.
						</p>
						<div class="code-block">
							<button class="copy-btn">Copy</button>
							<pre class="p-4 text-sm text-gray-300 overflow-x-auto"><code>// contexts/QuipubaseContext.jsx
																																			import React, { createContext, useContext, useMemo } from 'react';
																																			import { QuipuBase } from 'quipubase'; // Updated import
																																			
																																			const QuipubaseContext = createContext(null);
																																			
																																			export const QuipubaseProvider = ({ children, baseUrl }) => {
																																			    // Memoize the client instance to prevent re-creation on re-renders
																																			    const client = useMemo(() => new QuipuBase(baseUrl), [baseUrl]);
																																			
																																			    return (
																																			        &lt;QuipubaseContext.Provider value={client}&gt;
																																			            {children}
																																			        &lt;/QuipubaseContext.Provider>
																																			    );
																																			};
																																			
																																			export const useQuipubase = () => {
																																			    const context = useContext(QuipubaseContext);
																																			    if (!context) {
																																			        throw new Error('useQuipubase must be used within a QuipubaseProvider');
																																			    }
	return context;
	};</code></pre>
	</div>
	</div>
					<div class="mb-6">
						<h3 class="text-xl font-semibold text-gray-800 mb-3">Custom Hook
							(<code>hooks/useQuipubaseCollection.js</code>)</h3>
						<p class="text-gray-600 mb-3">
							This hook encapsulates the logic for subscribing to a collection and handling real-time
							events,
							providing a clean API for your React components.
						</p>
						<div class="code-block">
							<button class="copy-btn">Copy</button>
							<pre class="p-4 text-sm text-gray-300 overflow-x-auto"><code>// hooks/useQuipubaseCollection.js
																									import { useState, useEffect, useCallback } from 'react';
																									import { useQuipubase } from '../contexts/QuipubaseContext'; // Adjust path as needed
																									import { BaseModel } from 'quipubase'; // Ensure BaseModel is imported if used in types
																									
																									export const useQuipubaseCollection = (collectionId) => {
																									    const client = useQuipubase(); // Get the Quipubase client from context
																									    const [data, setData] = useState([]);
																									    const [loading, setLoading] = useState(false);
																									    const [error, setError] = useState(null);

	useEffect(() => {
	let unsubscribe;
	const subscribe = async () => {
	try {
				setLoading(true);
				// Subscribe to real-time events for the specified collection
				unsubscribe = await client.subscribeToEvents(collectionId, (sseEvent) => {
				const { event, data: eventData } = sseEvent; // Destructure SSEEvent
				
				setData(prevData => {
				switch (event) {
				case 'create':
				// Add new document
				return [...prevData, eventData];
				case 'update':
				// Update existing document
				return prevData.map(item =>
				item.id === eventData.id ? eventData : item
				);
				case 'delete':
				// Remove deleted document
				return prevData.filter(item => item.id !== eventData.id);
				default:
				return prevData;
				}
					});
					});
					} catch (err) {
					setError(err);
					console.error("Failed to subscribe to Quipubase events:", err);
					} finally {
					setLoading(false);
					}
		};
		
		subscribe(); // Initiate subscription
		return () => unsubscribe?.(); // Clean up subscription on unmount
		}, [client, collectionId]); // Re-subscribe if client or collectionId changes
		
		// Memoize the publish function to prevent unnecessary re-renders
		const publish = useCallback(async (event, eventData) => {
		try {
		await client.publishEvent(collectionId, { event, data: eventData });
		} catch (err) {
		setError(err);
		console.error("Failed to publish event to Quipubase:", err);
		}
	}, [client, collectionId]);
	
	return { data, loading, error, publish };
	};</code></pre>
	</div>
	</div>
	</section>
				<section id="react-examples" class="section">
					<h2 class="text-3xl font-bold text-gray-900 mb-6">React Examples: Building Interactive UIs!</h2>
					<p class="text-lg text-gray-600 mb-6">
						Here's how you can use the `useQuipubaseCollection` hook to build a reactive Todo List component
						in React.
					</p>
					<div class="mb-6">
						<h3 class="text-xl font-semibold text-gray-800 mb-3">Todo List Component
							(<code>components/TodoList.jsx</code>)</h3>
						<div class="code-block">
							<button class="copy-btn">Copy</button>
							<pre class="p-4 text-sm text-gray-300 overflow-x-auto"><code>// components/TodoList.jsx
																				import React, { useState } from 'react';
																				import { useQuipubaseCollection } from '../hooks/useQuipubaseCollection'; // Adjust path as needed
																				import { BaseModel } from 'quipubase'; // Import BaseModel to define Todo
																				import { z } from 'zod'; // Import z for schema definition

// Define the Todo model here or import it from a shared file
class Todo extends BaseModel {
title;
completed;
createdAt;

	static schema() {
	return z.object({
	id: z.string().optional(),
	title: z.string().min(1, 'Title is required'),
	completed: z.boolean().default(false),
	createdAt: z.string().transform((str) => new Date(str)).default(() => new Date().toISOString()) // Store as ISO string
	});
    }
}
const TodoList = ({ collectionId }) => {
// Use the custom hook to manage data and publish events
const { data, loading, error, publish } = useQuipubaseCollection(collectionId);
const [newTodo, setNewTodo] = useState('');

const addTodo = async (e) => {
e.preventDefault(); // Prevent default form submission
if (!newTodo.trim()) return; // Don't add empty todos

// Create a new Todo instance and use .modelDump()
const todoInstance = new Todo({
title: newTodo,
completed: false,
createdAt: new Date().toISOString()
});

await publish('create', todoInstance.modelDump()); // Use .modelDump()
setNewTodo(''); // Clear input
};

const toggleTodo = async (todo) => {
// Create a new Todo instance from existing data and update it
const updatedTodoInstance = new Todo({
...todo,
completed: !todo.completed
});
await publish('update', updatedTodoInstance.modelDump()); // Use .modelDump()
};

const deleteTodo = async (todo) => {
await publish('delete', { id: todo.id }); // Only need the ID for delete
};

if (loading) return &lt;div className="loading"&gt;Loading your real-time todos...&lt;/div&gt;;
if (error) return &lt;div className="error"&gt;Error: {error.message}&lt;/div&gt;;
if (data.length === 0) return &lt;div className="loading"&gt;No todos yet! Add one above.&lt;/div&gt;;

return (
&lt;div className="todo-list"&gt;
&lt;h2&gt;My React Todos&lt;/h2&gt;

&lt;form onSubmit={addTodo}&gt;
&lt;input
type="text"
value={newTodo}
onChange={(e) => setNewTodo(e.target.value)}
placeholder="Add a new Quipubase-powered todo..."
required
/&gt;
&lt;button type="submit"&gt;Add Todo&lt;/button&gt;
&lt;/form&gt;

&lt;ul&gt;
{data.map(todo => (
&lt;li key={todo.id} className="todo-item"&gt;
&lt;input
type="checkbox"
checked={todo.completed}
onChange={() => toggleTodo(todo)}
/&gt;
&lt;span className={todo.completed ? 'completed' : ''}&gt;{todo.title}&lt;/span&gt;
&lt;button onClick={() => deleteTodo(todo)}&gt;Delete&lt;/button&gt;
&lt;/li&gt;
))}
&lt;/ul&gt;
&lt;/div&gt;
);
};

export default TodoList;</code></pre>
</div>
</div>
				</section>

				<section id="realtime" class="section">
					<h2 class="text-3xl font-bold text-gray-900 mb-6">Real-time Updates: The Heartbeat of Quipubase</h2>
					<p class="text-lg text-gray-600 mb-6">
						Quipubase is built for speed and reactivity. Our WebSocket-based pub/sub system ensures that
						any change to your data is instantly propagated to all connected clients.
						This means your users always see the most up-to-date information without refreshing!
					</p>
					<p class="text-lg text-gray-600 mb-6">
						Imagine building collaborative apps, live dashboards, or chat applications where every user's
						action is reflected instantly. Quipubase makes this a reality with minimal effort.
					</p>
					<h3 class="text-xl font-semibold text-gray-800 mb-3">How it Works:</h3>
					<ul class="list-disc list-inside text-gray-600 mb-6 space-y-2">
						<li><strong>Subscribe:</strong> Your frontend subscribes to specific collections.</li>
						<li><strong>Publish:</strong> When data changes (create, update, delete), your application
							publishes an event.</li>
						<li><strong>Propagate:</strong> Quipubase instantly broadcasts these events to all relevant
							subscribers.</li>
						<li><strong>React:</strong> Your frontend framework (Vue, React) reacts to these events,
							updating the UI in real-time.</li>
					</ul>
					<div class="code-block">
						<button class="copy-btn">Copy</button>
						<pre class="p-4 text-sm text-gray-300 overflow-x-auto"><code>// Example: Subscribing to a collection
																														const unsubscribe = await client.subscribeToEvents('my-collection-id', (sseEvent) => {
																														    const { event, data } = sseEvent; // Destructure SSEEvent
																														    console.log('Real-time event received:', event, data);
																														    // Update your UI based on event (create, update, delete) and data
																														});
// Example: Publishing an update
await client.publishEvent('my-collection-id', {
event: 'update',
data: { id: 'some-item-id', status: 'completed' }
});

// Don't forget to unsubscribe when no longer needed!
// unsubscribe();</code></pre>
</div>
</section>

				<section id="schema-validation" class="section">
					<h2 class="text-3xl font-bold text-gray-900 mb-6">JSON Schema & Validation: Data Integrity,
						Simplified</h2>
					<p class="text-lg text-gray-600 mb-6">
						Quipubase leverages the power of **JSON Schema** through `zod` to ensure your data is always
						structured, valid, and consistent. No more rogue data entries or unexpected types!
						This built-in validation layer catches errors early, making your applications more robust and
						reliable.
					</p>
					<p class="text-lg text-gray-600 mb-6">
						Defining your data models with `zod` is intuitive and powerful. You get:
					</p>
					<ul class="list-disc list-inside text-gray-600 mb-6 space-y-2">
						<li><strong>Type Safety:</strong> Define expected data types (strings, numbers, booleans, dates,
							arrays, objects).</li>
						<li><strong>Validation Rules:</strong> Add constraints like `min`, `max`, `email`, `url`, custom
							validations.</li>
						<li><strong>Default Values:</strong> Automatically assign defaults for missing fields.</li>
						<li><strong>Readability:</strong> Clear and concise schema definitions that double as
							documentation.</li>
					</ul>
					<h3 class="text-xl font-semibold text-gray-800 mb-3">Defining a Complex Schema:</h3>
					<p class="text-gray-600 mb-3">
						Let's define a schema for a `Product` with nested objects and arrays.
					</p>
					<div class="code-block">
						<button class="copy-btn">Copy</button>
						<pre class="p-4 text-sm text-gray-300 overflow-x-auto"><code>import { z } from 'zod';
																				import { BaseModel } from 'quipubase'; // Updated import
																				
																				const ProductVariantSchema = z.object({
																				    color: z.string(),
																				    size: z.enum(['S', 'M', 'L', 'XL']),
																				    price: z.number().positive(),
																				    stock: z.number().int().min(0)
																				});
																				
																				class Product extends BaseModel {
																				    name!: string;
																				    description?: string;
																				    category!: string;
																				    variants!: z.infer&lt;typeof ProductVariantSchema&gt;[];
																				    tags?: string[];
																				    createdAt!: Date;
																				    updatedAt!: Date;

	static schema() {
	return z.object({
	id: z.string().optional(),
	name: z.string().min(3, 'Product name is required and must be at least 3 characters'),
	description: z.string().optional(),
	category: z.string().min(1, 'Category is required'),
	variants: z.array(ProductVariantSchema).min(1, 'At least one variant is required'),
	tags: z.array(z.string()).optional(),
	createdAt: z.date().default(() => new Date()),
	updatedAt: z.date().default(() => new Date())
	});
    }
}
// Example of creating a new product and dumping its model
const newProduct = new Product({
name: "Quipubase T-Shirt",
category: "Apparel",
variants: [
{ color: "Black", size: "M", price: 29.99, stock: 100 },
{ color: "White", size: "L", price: 29.99, stock: 50 }
],
tags: ["clothing", "merch"]
});

// Quipubase automatically validates this against your schema on creation/update!
console.log(newProduct.modelDump()); // Updated: Use .modelDump()

// Example of validating JSON data against the schema
const jsonString = JSON.stringify({
name: "Quipubase Mug",
category: "Drinkware",
variants: [{ color: "Blue", size: "One Size", price: 15.00, stock: 200 }]
});
const validatedProduct = Product.modelValidateJson(jsonString);
if (validatedProduct) {
console.log("Validated product from JSON:", validatedProduct.modelDump());
} else {
console.error("JSON validation failed.");
}</code></pre>
</div>
				</section>

				<section id="vectors" class="section">
					<h2 class="text-3xl font-bold text-gray-900 mb-6">AI & Vector Search: Smarter Data Retrieval</h2>
					<p class="text-lg text-gray-600 mb-6">
						Quipubase isn't just a database; it's an intelligent data companion!
						With built-in support for **vector embeddings** and **AI-powered similarity search**,
						you can go beyond keyword matching and find data based on its meaning and context.
					</p>
					<p class="text-lg text-gray-600 mb-6">
						Imagine a knowledge base where users can ask questions in natural language and get
						relevant documents, not just those containing exact keywords. Or an e-commerce site
						where recommending products based on "similar style" is effortless.
						This is the magic of vector search!
					</p>
					<h3 class="text-xl font-semibold text-gray-800 mb-3">How Vector Search Works:</h3>
					<ul class="list-disc list-inside text-gray-600 mb-6 space-y-2">
						<li><strong>Embeddings:</strong> Textual or other data is transformed into numerical vectors
							(embeddings) by an AI model.
							These vectors capture the semantic meaning of the data.</li>
						<li><strong>Indexing:</strong> Quipubase stores these embeddings alongside your documents.</li>
						<li><strong>Similarity Search:</strong> When you query with a new piece of text (which is also
							embedded),
							Quipubase finds documents whose embeddings are "closest" in the vector space, indicating
							semantic similarity.</li>
					</ul>
					<h3 class="text-xl font-semibold text-gray-800 mb-3">Performing Vector Store Operations:</h3>
					<p class="text-gray-600 mb-3">
						Quipubase provides methods to `embed` text, `upsertVectors` for indexing, `queryVectors` for
						semantic search, and `deleteVectors`.
					</p>
					<div class="code-block">
						<button class="copy-btn">Copy</button>
						<pre class="p-4 text-sm text-gray-300 overflow-x-auto"><code>// Assuming 'client' is your initialized QuipuBase client
																														
																														// 1. Embed Text: Convert text into numerical vectors
																														const embedResponse = await client.embed({
																														    content: ["The quick brown fox jumps over the lazy dog.", "A group of cats is called a clowder."],
																														    model: "poly-sage" // Choose your embedding model
																														});
																														console.log("Embeddings generated:", embedResponse.data);
																														
																														// 2. Upsert Vectors: Store embeddings in a namespace
																														const upsertResponse = await client.upsertVectors({
																														    namespace: "my-documents",
																														    texts: ["The quick brown fox jumps over the lazy dog.", "A group of cats is called a clowder."],
																														    model: "poly-sage"
																														});
																														console.log("Vectors upserted:", upsertResponse.ids);
																														
																														// 3. Query Vectors: Find semantically similar content
																														const queryResponse = await client.queryVectors({
																														    namespace: "my-documents",
	query: "What is a group of felines called?",
	top_k: 2, // Retrieve top 2 most similar results
	model: "poly-sage"
	});
	console.log("Semantic search results:");
	queryResponse.matches.forEach(match => {
	console.log(`- Content: "${match.content}" (Score: ${match.score})`);
	});

// 4. Delete Vectors: Remove embeddings from a namespace
const deleteResponse = await client.deleteVectors({
namespace: "my-documents",
	ids: upsertResponse.ids // Delete the vectors we just upserted
	});
	console.log("Vectors deleted:", deleteResponse.deletedCount);</code></pre>
	</div>
				</section>

				<section id="document-processing" class="section">
					<h2 class="text-3xl font-bold text-gray-900 mb-6">Document Processing: Beyond Simple Data</h2>
					<p class="text-lg text-gray-600 mb-6">
						Quipubase isn't just for small key-value pairs; it's a full-fledged **document collection
						database**.
						This means you can store rich, complex JSON documents, making it ideal for applications that
						deal with varied and evolving data structures, like content management systems, knowledge bases,
						or user profiles with extensive details.
					</p>
					<p class="text-lg text-gray-600 mb-6">
						Our flexible document model, combined with JSON Schema validation, allows you to define and
						enforce
						structure where needed, while still enjoying the agility of a NoSQL-like database.
						Store articles, product specifications, user generated content, and more â€“ all within Quipubase.
					</p>
					<h3 class="text-xl font-semibold text-gray-800 mb-3">Use Cases for Document Processing:</h3>
					<ul class="list-disc list-inside text-gray-600 mb-6 space-y-2">
						<li><strong>Content Management Systems (CMS):</strong> Store articles, blog posts, pages with
							rich text, images, and metadata.</li>
						<li><strong>Knowledge Bases:</strong> Organize FAQs, guides, and support documentation.</li>
						<li><strong>User Profiles:</strong> Store detailed user information, preferences, and activity
							logs.</li>
						<li><strong>E-commerce Catalogs:</strong> Manage product details, specifications, and
							variations.</li>
						<li><strong>Event Logging:</strong> Store application events or user interactions for analytics.
						</li>
					</ul>
					<h3 class="text-xl font-semibold text-gray-800 mb-3">Example: Storing an Article Document</h3>
					<p class="text-gray-600 mb-3">
						Define a schema for an `Article` and store it as a document.
					</p>
					<div class="code-block">
						<button class="copy-btn">Copy</button>
						<pre class="p-4 text-sm text-gray-300 overflow-x-auto"><code>import { z } from 'zod';
																														import { BaseModel } from 'quipubase'; // Updated import
																														
																														const AuthorSchema = z.object({
																														    name: z.string(),
																														    email: z.string().email().optional()
																														});
																														
																														class Article extends BaseModel {
																														    title!: string;
																														    content!: string; // Could be rich text/Markdown
																														    author!: z.infer&lt;typeof AuthorSchema&gt;;
																														    tags!: string[];
																														    publishedAt!: Date;
																														    isPublished!: boolean;
																														
																														    static schema() {
																														        return z.object({
																														            id: z.string().optional(),
																														            title: z.string().min(5, 'Title must be at least 5 characters'),
																														            content: z.string().min(20, 'Content cannot be too short'),
																														            author: AuthorSchema,
																														            tags: z.array(z.string()).default([]),
																														            publishedAt: z.date().default(() => new Date()),
																														            isPublished: z.boolean().default(false)
																														        });
    }
}
// Create a new article document
const newArticle = new Article({
title: "The Future of Frontend Databases with Quipubase",
content: "Lorem ipsum dolor sit amet, consectetur adipiscing elit...",
author: { name: "Jane Doe", email: "jane.doe@example.com" },
tags: ["database", "frontend", "real-time", "ai"],
isPublished: true
});

// Add the article to a collection
// const articleCollection = await client.createCollection(Article);
// await client.publishEvent(articleCollection.id, { event: 'create', data: newArticle.modelDump() }); // Updated: Use
.modelDump()

console.log("New article document ready:", newArticle.modelDump()); // Updated: Use .modelDump()</code></pre>
</div>
</section>

				<section id="file-chunking" class="section">
					<h2 class="text-3xl font-bold text-gray-900 mb-6">File Chunking: Prepare Documents for AI</h2>
					<p class="text-lg text-gray-600 mb-6">
						Quipubase provides a convenient utility to **chunk large text files** into smaller, manageable
						segments.
						This is incredibly useful when preparing documents for AI models, especially for tasks like
						semantic search or RAG (Retrieval Augmented Generation), where models perform best on smaller,
						focused pieces of information.
					</p>
					<p class="text-lg text-gray-600 mb-6">
						The `chunkFile` method helps you break down documents (like PDFs, HTML files, or plain text)
						into chunks that can then be embedded and stored in your vector store for efficient retrieval.
					</p>
					<h3 class="text-xl font-semibold text-gray-800 mb-3">How File Chunking Works:</h3>
					<ul class="list-disc list-inside text-gray-600 mb-6 space-y-2">
						<li><strong>Input:</strong> Provide a `File` object and specify the format (e.g., "html" or
							"text").</li>
						<li><strong>Processing:</strong> Quipubase processes the file and intelligently breaks it into
							chunks.</li>
						<li><strong>Output:</strong> Returns an array of strings, where each string is a coherent chunk
							of the original file.</li>
					</ul>
					<h3 class="text-xl font-semibold text-gray-800 mb-3">Example: Chunking a File</h3>
					<p class="text-gray-600 mb-3">
						This example demonstrates how to use the `chunkFile` method.
						Note that `File` objects are typically obtained from user input elements like `<input type="file">`.
					</p>
					<div class="code-block">
						<button class="copy-btn">Copy</button>
						<pre class="p-4 text-sm text-gray-300 overflow-x-auto"><code>// Assuming 'client' is your initialized QuipuBase client
																														
																														// This is a placeholder for a File object. In a real app, you'd get this from user input.
																														// For demonstration, we'll create a dummy File.
																														const dummyFileContent = `&lt;h1&gt;My Awesome Document&lt;/h1&gt;
																														&lt;p&gt;This is the first paragraph of my document. It contains some important information.&lt;/p&gt;
																														&lt;p&gt;Here is the second paragraph, discussing more details about Quipubase features.&lt;/p&gt;
																														&lt;div&gt;
																														    &lt;ul&gt;
																														        &lt;li&gt;Feature 1&lt;/li&gt;
																														        &lt;li&gt;Feature 2&lt;/li&gt;
																														    &lt;/ul&gt;
																														&lt;/div&gt;`;
																														const dummyFile = new File([dummyFileContent], "my-document.html", { type: "text/html" });

// Chunk the HTML file
const chunkResponse = await client.chunkFile(dummyFile, "html");
console.log("File chunked successfully!");
chunkResponse.chunks.forEach((chunk, index) => {
console.log(`Chunk ${index + 1}:`, chunk);
});

// Example with a plain text file
const dummyTextFileContent = `Line one of text.
Line two of text.
Line three of text.`;
const dummyTextFile = new File([dummyTextFileContent], "my-text-document.txt", { type: "text/plain" });

const textChunkResponse = await client.chunkFile(dummyTextFile, "text");
console.log("Text file chunked successfully!");
textChunkResponse.chunks.forEach((chunk, index) => {
console.log(`Text Chunk ${index + 1}:`, chunk);
});</code></pre>
</div>
				</section>

			</main>
		</div>
		</div>

	<script>
							document.addEventListener('DOMContentLoaded', () => {
								const navItems = document.querySelectorAll('.nav-item');
								const sections = document.querySelectorAll('.section');
								const copyButtons = document.querySelectorAll('.copy-btn');

							// Function to show a specific section and update active nav item
							const showSection = (sectionId) => {
								sections.forEach(section => {
									section.classList.remove('active');
				});
							const targetSection = document.getElementById(sectionId);
							if (targetSection) {
								targetSection.classList.add('active');
							}

							navItems.forEach(item => {
								item.classList.remove('active');
								if (item.dataset.section === sectionId) {
									item.classList.add('active');
								}
						});
						};

							// Handle navigation clicks
							navItems.forEach(item => {
								item.addEventListener('click', (e) => {
					e.preventDefault();
								const sectionId = item.dataset.section;
								if (sectionId) {
									showSection(sectionId);
									// Update URL hash without page reload
									history.pushState(null, '', `#${sectionId}`);
					}
				});
			});

							// Handle initial load based on URL hash
							const initialHash = window.location.hash.substring(1);
							if (initialHash && document.getElementById(initialHash)) {
								showSection(initialHash);
							} else {
								showSection('overview'); // Default to overview
							}

							// Handle copy to clipboard
							copyButtons.forEach(button => {
								button.addEventListener('click', () => {
									const codeBlock = button.nextElementSibling; // The <pre> tag
									const code = codeBlock.querySelector('code').innerText;

								// Use execCommand for broader compatibility in iframes
								const textArea = document.createElement('textarea');
								textArea.value = code;
								document.body.appendChild(textArea);
								textArea.select();
								try {
									document.execCommand('copy');
									button.textContent = 'Copied!';
							setTimeout(() => {
								button.textContent = 'Copy';
							}, 2000);
							} catch (err) {
								console.error('Failed to copy text: ', err);
								button.textContent = 'Error!';
							} finally {
								document.body.removeChild(textArea);
					}
				});
						});
		});
</script>
</body>

</html>